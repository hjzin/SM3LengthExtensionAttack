#  SM3长度扩展攻击实验文档

1901210403 胡兆杰

## 实验思路

要实现长度扩展攻击，主要需完成下面几步。

1. 随机生成一个消息(secret)，用SM3函数算出hash值(hash1)
2. 生成一个附加消息(m')。首先用hash1推算出这一次加密结束后8个向量的值，再以它们作为初始向量，去加密m’，得到另一个hash值(hash2)
3. 计算secret + padding + m'的hash值(hash3)，如果攻击成功，hash2应该和hash3相等

**攻击原理**

SM3的消息长度是64字节或者它的倍数，如果消息的长度不足则需要padding。在padding时，首先填充一个1，随后填充0，直到消息长度为56(或者再加整数倍的64)字节，最后8字节用来填充消息的长度。

在SM3函数计算时，首先对消息进行分组，每组64字节，每一次加密一组，并更新8个初始向量(初始值已经确定)，下一次用新向量去加密下一组，以此类推。我们可以利用这一特性去实现攻击。当我们得到第一次加密后的向量值时，再人为构造一组消息用于下一次加密，就可以在不知道secret的情况下得到合法的hash值，这是因为8个向量中的值便能表示第一轮的加密结果。

## 实现细节

我随机生成了一个浮点数作为secret，并计算得到了hash值。要得到第一次加密之后8个向量的值，只需要将hash值按8字节分组，并把每组的值转换成int类型(因为python库的sm3实现中向量值是用int型存储的)。

得到了向量值后，便可以开始构造消息。由于我们不需要知道secret的值，只知道secret的长度，所以secret部分可以用等长的任意字符代替(我这里用的是’a')。随后进行padding，得到64字节的消息，再将附加信息放在后面，消息就构造完成了。

接着进行加密，由于此时只需要对附加的消息进行加密，所以我修改了一下sm3的函数实现，增加了一个`new_v`参数，表示更新之后的向量值。此外这次加密的次数要比之前少一次，从消息的第64字节开始加密，即可得到hash值。相关代码如下。

```python
group_count = round(len(msg) / 64) - 1	# 加密次数

    B = []
    for i in range(0, group_count):
        B.append(msg[(i + 1)*64:(i+2)*64])	# 从第64字节开始加密

    V = []
    V.append(new_v)	 # 用更新后的向量值作为初始值
    for i in range(0, group_count):
        V.append(sm3_cf(V[i], B[i]))
```

随后进行验证，我们计算secret + padding + m'的hash值，并判断攻击是否成功。

实验结果如下图。

![](https://tva1.sinaimg.cn/large/006y8mN6ly1g7x0i0cdrpj322a0sygms.jpg)



